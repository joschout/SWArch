\documentclass[a4paper,10pt]{article}

\usepackage[english]{babel}
\usepackage{graphicx}
\graphicspath{{./figures/}}
\usepackage[colorlinks, linkcolor=black, citecolor=black, urlcolor=black]{hyperref}
\usepackage{geometry}
\geometry{tmargin=3cm, bmargin=2.2cm, lmargin=2.2cm, rmargin=2cm}
\usepackage{todonotes} %Used for the figure placeholders

\begin{document}
\input{titlepage}

\tableofcontents
\newpage

\section{Introduction}\label{sec:introduction}

\section{Attribute-driven design documentation}\label{sec:add}
\subsection{Decomposition 1: The eDocs System (Av1, P1, UC4, UC5)}
\subsubsection{Module to decompose}
In this run we decompose the \emph{eDocs System} as a whole.

\subsubsection{Selected architectural drivers}
The selected non-functional drivers for this decomposition are:

\begin{itemize}
    \item \emph{Av1}: Document generation failure
    \item \emph{P1}: Document generation
\end{itemize}

There are two use cases about the generation of documents. These qre thus selected as the functional drivers. These use cases are:

\begin{itemize}
    \item \emph{UC4}: Generate payslip
    \item \emph{UC5}: Generate invoice
\end{itemize}

\paragraph{Rationale}
\emph{Av1} and \emph{P1} were chosen because both have a high priority. They where selected among the other high-priority quality requirements because they both concern the generation of documents, which is essential to the other requirements of the eDocs System.
UC4 and UC5 in the eDocs System rely on the generation of documents and are thus selected as functional drivers.

\subsubsection{Architectural design}
\paragraph{Deadline scheduling for P1}
P1 specifies that the system(s) processing the raw data must be able to cope with a potentially large amount of incoming data by scheduling the different processing jobs. For this we introduce the \texttt{DocumentGenerationScheduler} that takes a coordinating role and guarantees all deadlines for all processing jobs to be met. More precisely, the \texttt{DocumentGenerationScheduler} creates new processing jobs based on the raw data received. For document processing jobs regarding recurring batches of raw data, the \texttt{DocumentGenerationScheduler} assigns a deadline to the newly created jobs based on the priority stipulated in the SLA that was negotiated with the Customer Organisation who sent the raw data. For document processing jobs not part of recurring batches, the deadlines depend on the priority of the document itself, which can be retrieved from the meta data. Furthermore, the \texttt{QueueManager} maintains a dynamic queue to which the \texttt{DocumentGenerationScheduler} adds these newly created processing jobs according to their deadline. Notice that restarted documents are also put back into the queue once their generation process is restarted by the scheduler, this happens when the service offered by one or more \texttt{DocumentGenerationProcessors} is somehow disrupted. 

\paragraph{Parallel processing for P1}
The \texttt{QueueManager}, that we introduced earlier, is sent a pull request on a regular basis by the \texttt{DocumentGenerationProcessorManager}, which in turn provides an interface to one or more \texttt{DocumentGenerationProcessors} to request a job to be processed, following a shortest-deadline-first approach in order to prevent documents from being processed beyond their respective deadline. This \texttt{DocumentGenerationProcessorManager} oversees all processing tasks and has the ability to detect defective \texttt{DocumentGenerationProcessors}. When this \texttt{DocumentGenerationProcessorManager} detects such a defect, the document currently being generated on the respective \texttt{DocumentGenerationProcessor} will be marked as \textit{restarted} and put back into the queue that is accessed through the \texttt{QueueManager}.Notice that the processing capacity of the eDocs System can now be adjusted dynamically due to the pull methodology we just discussed.

\paragraph{Dedicated persistent databases for Av1}
Besides the performance of the system processing raw data, it is also important that all types of persistent data remain available in the presence of software or hardware failures.
First, Av1 specifies that a failure of the internal infrastructure for generating documents from raw data does not affect the availability of any type of persistent data, such as (i) the personal document stores, (ii) the status of ongoing document processing jobs, (iii) billing data, etc. Therefore, the storage of persistent data is handled by dedicated databases, or more precisely, the components handling the storage of persistent data do not handle the generation of documents. For security reasons, we introduce database components for different persistent datatypes. We introduce two database components at this point, \texttt{TemplateDB} and \texttt{DocumentDB}. \texttt{TemplateDB} contains the templates for documents to be generated. The \texttt{DocumentGenerationScheduler} queries this database for the required template when composing a document generation job.  The database also offers an interface for updating templates. The \texttt{DocumentDB} can also be queried and updated.

\paragraph{Unaffected functionality of other components}
Next to storing the  persistent data in a dedicated databases, Av1 also requires the other functionality of the system to remain unaffected when the infrastructure for document generation fails or crashes. This functionality includes (i) the personal document stores, (ii) the status overview for Customer Administrator, (iii) delivering the raw data, etc.
We therefore 

\paragraph{Unique document generation for Av1}
Av1 also requires documents to be generated and delivered exactly once. This is accomplished by the \texttt{DocumentGenerationProcessorManager} overseeing all processing jobs that are running on the active \texttt{DocumentGenerationProcessors}. More specifically, the \texttt{DocumentGenerationProcessorManager} is notified by a \texttt{DocumentGenerationProcessor} when the latter completes its job. Subsequently, the \texttt{DocumentGenerationProcessorManager} checks the \texttt{QueueManager} for any other \texttt{DocumentGenerationProcessors} committed to this job: if there are any, the \texttt{DocumentGenerationProcessorManager} cancels their job and assigns them a new one from the queue. Finally, the \texttt{DocumentGenerationProcessorManager} gives the finished \texttt{DocumentGenerationProcessor} permission to write its generated document into the \texttt{DocumentDB}. Notice that two \texttt{DocumentGenerationProcessors} can indeed be working on the same job: imagine the \texttt{DocumentGenerationProcessorManager} losing connectivity with a \texttt{DocumentGenerationProcessor} working on a specific job, which causes the \texttt{DocumentGenerationProcessorManager} to put this job (which is now given the status \textit{restarted}) back into the queue where it could be requested by another \texttt{DocumentGenerationProcessor} once again.

\subsubsection*{Alternatives considered}
\paragraph{Alternatives for active replication}


\subsubsection{Instantiation and allocation of functionality}
\paragraph{Decomposition}
Main aspects of the resulting decomposition.

\subparagraph{ModuleB}
Per introduced component a paragraph describing its responsibilities.

\subparagraph{ModuleC}
Per introduced component a paragraph describing its responsibilities.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Component-and-connector diagram}
    \caption{Component-and-connector diagram of this decomposition.
        }\label{fig:it1-cc_main}
\end{figure}

\paragraph{Behaviour}
If needed and explanation of the behaviour of certain aspects of the design so
far.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Sequence diagram}
    \caption{Sequence diagram illustrating a key behavioural aspect.
        }\label{fig:it1-seq_aspect1}
\end{figure}

\paragraph{Deployment}
Rationale of the allocation of components to physical nodes.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Deployment diagram}
    \caption{Deployment diagram of this decomposition.
        }\label{fig:it1-depl_main}
\end{figure}

\subsubsection{Interfaces for child modules}
\subsubsection*{ModuleB}
\begin{itemize}
    \item InterfaceA
    \begin{itemize}
        \item \texttt{returnType operation1(ParamType param1)} throws TypeOfException
        \begin{itemize}
            \item Effect: Describe the effect of calling this operation.
            \item Exceptions: 
            \begin{itemize}
                \item TypeOfException: Describe when this exception is thrown.
            \end{itemize}
        \end{itemize}

        \item \texttt{returnType operation2()}
        \begin{itemize}
            \item Effect: Describe the effect of calling this operation.
            \item Exceptions: None
         \end{itemize}
    \end{itemize}
\end{itemize}

\subsubsection{Data type definitions}
Describe per complex data type used in the interfaces what it represents.

\paragraph{returnType} This data element represents X.

\paragraph{ParamType} This data element represents Y.

\subsubsection{Verify and refine}
This section describes per component which (parts of) the remaining
requirements it is responsible for.

\paragraph{ModuleB}
\begin{itemize}
    \item \emph{Z1}: name
    \item \emph{UCd}: name
\end{itemize}

\paragraph{ModuleC}
\begin{itemize}
    \item \emph{UCba}: name\\Description which part of the original use case is
        the responsibility of this component.
\end{itemize}

\subsection{Decomposition 2: Delivery functionality (Av2, P2, UC11, UC12, UC13, UC14)}
\subsubsection{Module to decompose}
In this run we decompose the \emph{delivery functionality} that was introduced in the first decomposition.

\subsubsection{Selected architectural drivers}
The selected non-functional drivers for this decomposition are:

\begin{itemize}
	\item \emph{Av2}: Personal document storage failure
	\item \emph{P2}: Document lookups
\end{itemize}

There are two use cases about the generation of documents. These qre thus selected as the functional drivers. These use cases are:

\begin{itemize}
	\item \emph{UC11}: Deliver document via personal document store
	\item \emph{UC12}: Consult personal document store
	\item \emph{UC13}: Search documents in personal document store
	\item \emph{UC14}: Consult document in personal document store
\end{itemize}

\paragraph{Rationale}

\subsubsection{Architectural design}
\paragraph{Scheduling for P1}


\paragraph{Dedicated persistent databases for Av1}


\paragraph{Unaffected functionality of other components}


\paragraph{Unique document generation and delivery for Av1}



\subsubsection*{Alternatives considered}
\paragraph{Alternatives for solution}
A discussion of the alternative solutions and why that were not selected.

\subsubsection{Instantiation and allocation of functionality}
\paragraph{Decomposition}
Main aspects of the resulting decomposition.

\subparagraph{ModuleB}
Per introduced component a paragraph describing its responsibilities.

\subparagraph{ModuleC}
Per introduced component a paragraph describing its responsibilities.

\begin{figure}[!htp]
	\centering
	%\includegraphics[width=0.8\textwidth]{}
	\missingfigure[figwidth=0.8\textwidth]{Component-and-connector diagram}
	\caption{Component-and-connector diagram of this decomposition.
	}\label{fig:it1-cc_main}
\end{figure}

\paragraph{Behaviour}
If needed and explanation of the behaviour of certain aspects of the design so
far.

\begin{figure}[!htp]
	\centering
	%\includegraphics[width=0.8\textwidth]{}
	\missingfigure[figwidth=0.8\textwidth]{Sequence diagram}
	\caption{Sequence diagram illustrating a key behavioural aspect.
	}\label{fig:it1-seq_aspect1}
\end{figure}

\paragraph{Deployment}
Rationale of the allocation of components to physical nodes.

\begin{figure}[!htp]
	\centering
	%\includegraphics[width=0.8\textwidth]{}
	\missingfigure[figwidth=0.8\textwidth]{Deployment diagram}
	\caption{Deployment diagram of this decomposition.
	}\label{fig:it1-depl_main}
\end{figure}

\subsubsection{Interfaces for child modules}
\subsubsection*{ModuleB}
\begin{itemize}
	\item InterfaceA
	\begin{itemize}
		\item \texttt{returnType operation1(ParamType param1)} throws TypeOfException
		\begin{itemize}
			\item Effect: Describe the effect of calling this operation.
			\item Exceptions: 
			\begin{itemize}
				\item TypeOfException: Describe when this exception is thrown.
			\end{itemize}
		\end{itemize}
		
		\item \texttt{returnType operation2()}
		\begin{itemize}
			\item Effect: Describe the effect of calling this operation.
			\item Exceptions: None
		\end{itemize}
	\end{itemize}
\end{itemize}

\subsubsection{Data type definitions}
Describe per complex data type used in the interfaces what it represents.

\paragraph{returnType} This data element represents X.

\paragraph{ParamType} This data element represents Y.

\subsubsection{Verify and refine}
This section describes per component which (parts of) the remaining
requirements it is responsible for.

\paragraph{ModuleB}
\begin{itemize}
	\item \emph{Z1}: name
	\item \emph{UCd}: name
\end{itemize}

\paragraph{ModuleC}
\begin{itemize}
	\item \emph{UCba}: name\\Description which part of the original use case is
	the responsibility of this component.
\end{itemize}

\subsection{Decomposition 3: Module (drivers)}
\subsubsection{Module to decompose}
\subsubsection{Selected architectural drivers}
\subsubsection{Architectural design}
\subsubsection{Instantiation and allocation of functionality}
\subsubsection{Interfaces for child modules}
\subsubsection{Data type definitions}
\subsubsection{Verify and refine}

\section{Resulting partial architecture}\label{sec:architecture}
This section provides an over of the architecture constructed through ADD\@.

\subsection{Context diagram}
This subsection discusses the context diagram.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Context diagram for component-and-
        connector view.}
    \caption{Context diagram for the component-and-connector view.
        }\label{fig:cc_context}
\end{figure}

\subsection{Component-and-connector view}
A short discussion of the component-and-connector view with the key
decompositions if any.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Component-and-connector diagram}
    \caption{Primary diagram for the component-and-connector view.
        }\label{fig:cc_main}
\end{figure}

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Key decomposition}
    \caption{Decomposition of a component shown in Figure~\ref{fig:cc_main}
        }\label{fig:decomp_decomp1}
\end{figure}

\subsection{Deployment view}
A short discussion of the allocation of components to physical nodes based on a
context diagram and a deployment diagram.

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Context diagram for the allocation
        view.}
    \caption{Context diagram for the allocation view.}\label{fig:depl_context}
\end{figure}

\begin{figure}[!htp]
    \centering
    %\includegraphics[width=0.8\textwidth]{}
    \missingfigure[figwidth=0.8\textwidth]{Deployment diagram}
    \caption{Primary diagram for the allocation view.}\label{fig:depl_main}
\end{figure}

\end{document}
